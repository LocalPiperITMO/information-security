# Работа 1: Разработка защищенного REST API с интеграцией в CI/CD
Сервис реализован на Java с использованием фреймворка Spring

## Доступные эндпойнты

###  `POST /auth/register` - регистрация пользователя в системе

**Пример использования:**
```sh
curl -s -X POST http://localhost:8080/auth/register \
                                    -H "Content-Type: application/json" \
                                    -d '{"login":"alice","password":"123456"}'
```
**Ответ:**

Status Code 200 - регистрация прошла успешно
```
{"msg":"registered"}
```

Status Code 400 - имя пользователя занято
```
{"error":"username_taken"}
```
Эндпойнт не защищен (не требуется аутентификация)

###  `POST /auth/login` - аутентификация пользователя

**Пример использования:**
```sh
curl -s -X POST http://localhost:8080/auth/login \
                                    -H "Content-Type: application/json" \
                                    -d '{"login":"alice","password":"123456"}'
```
**Ответ:**

Status Code 200 - пользователю возвращается JWT
```
{"token":"jwt_example"}
```

Status Code 401 - неверные имя пользователя/пароль
```
{"error":"invalid_credentials"}
```
Эндпойнт не защищен (не требуется аутентификация)

###  `GET /api/data` - получение списка пользователей

**Пример использования:**
```sh
curl http://localhost:8080/api/data \
                                    -H "Authorization: Bearer jwt_example"
```
**Ответ:**

Status Code 200 - пользователю возвращается список пользователей, где для каждого пользователя выводится ID и логин
```
[{"id":1,"username":"alice"}]
```

Status Code 401 - неправильный/истекший JWT
```
{"error":"Invalid or expired token"}
```
Также выдает 401 если заголовок не передан в запрос

Эндпойнт защищен (требуется аутентификация)

## Реализованные меры защиты

### Секреты
Обращения к защищенным данным (таким как секретный ключ для JWT и ID для подключения к Snyk) происходят через переменные окружения - а сами ключи (в случае работы с CI) хранятся в Github Secrets

### Аутентификация
При успешной регистрации пользователя в системе (`/auth/register`) пароль сохраняется в базу данных SQLite в зашифрованном виде с использованием алгоритма bcrypt. Возможности восстановить исходное значение пароля нет.
При успешной аутентификации пользователя в системе (`/auth/login`) на сервере создается JWT и возвращается пользователю
При обращении к защищенному эндпойнту (`/api/data`) запрос перехватывается фильтром `JwtAuthFilter`, который проверяет наличие JWT среди заголовков запроса и корректность JWT с использованием сервиса `JwtService`. Если JWT есть (и корректный) - запрос переходит на `DataController` для последующей обработки, иначе возвращается код 401

### Защита от SQL-инъекций
SQL-запросы не вызываются напрямую - для работы с базой данных SQLite используется ORM Hibernate и ее инструменты. Доступные запросы к БД описаны в интерфейсе `UserRepository` в виде функций, их реализация ложится на Hibernate. "Сырые" SQL-запросы в сервисе не создаются.

### Защита от XSS-атак
Реализована как на ввод, так и на вывод. Для входных данных на эндпойнт `/auth/register` поставлено ограничение на символы для поля `login` с помощью аннотации `@Pattern` и регулярного выражения - так мы защищаем БД от вредоносных данных со стороны клиента.
Для эндпойнта `/api/data` - возвращается JSON, где пользователи представлены в виде:
```json
{
  "id" : "number",
  "username" : "string"
}
```
где значение username всегда экранировано кавычками - это строка. Для дополнительной защиты (если вдруг вредоносные данные появились в БД) перед добавлением в JSON значение обрабатывается функцией `StringEscapeUtils.escapeHtml4()`, которая экранирует символы, такие как `<`, `>`, `&` и `"`.

## Отчеты
Снимки отчетов с последнего запуска pipeline ниже

### SAST (Java SpotBugs)

<img width="777" height="779" alt="image" src="https://github.com/user-attachments/assets/e081ca3a-a11e-402c-9bbd-8f81916ba63c" />
<img width="1911" height="604" alt="image" src="https://github.com/user-attachments/assets/4834a5eb-5131-4810-b1ba-c7a733c22eb0" />

Ранее обнаруженные (и устраненные) уязвимости:
- CT (Bad practice, medium priority) - конструктор `JwtService` мог выбросить исключение
- Dm (Internationalization, high priority) - вызов `.getBytes()` без аргументов (по умолчанию)
- EI2 (Malicious code vulnerability, medium priority) - ссылка на изменяемый объект `JwtAuthFilter`
- SECSPRCSRFPD (Security, high priority) - CSRF-защита явно отключена

### SCA (Snyk)

<img width="1207" height="622" alt="image" src="https://github.com/user-attachments/assets/4d4a61eb-4ba7-42d5-9add-12d4739f6d5e" />

Ранее была обнаружена уязвимость - модуль `commons-text` использовал модуль `commons-lang3`, который вплоть до версии 3.17.X имел уязвимость [CVE-2025-48924](https://www.cve.org/CVERecord?id=CVE-2025-48924) - помогла замена на версию 3.18.X (на данный момент является последней)
